"use strict";
/**
 * Automatic modules loader based on file naming convention.
 * This module will traverse `./modules` directory, relative to the app.js.
 * usage: var manager = require('modex')(options);
 *        manager.start();
 * options :
 *   paths.modules - relative path of the directory that contains all the modules. Default: 'modules'
 *   modules - an object that contains optional settings for modules.
 * Public API:
 * app, logger, findByInterface, findByName, findByNamespace, controllers, views
 */
var path = require('path');
var fs = require('fs');
var http = require('http');
var express = require('express');
var jsx = require('jsx');
var viewRenderers = require('./views').renderers;
var formatResolver = require('./format_resolver');
var merge = require('./utils').merge;
var forEachSerial = require('./utils').forEachSerial;
var mapByName = {};
var mapByNamespace = {};
//var mapByRoute = {};
//var viewsDir = path.join(__dirname, 'views');
var moduleSettings;
var settings;
var logger;

function loadStates(modulesPath) {
  var key;
  try {
    var states = require( path.join(modulesPath, 'modules.json') );
    for (key in states) {
      if (key in mapByNamespace) mapByNamespace[key]._load(states[key]);
    }
    for (key in mapByNamespace) {
      if (!(key in states)) return true;
    }  
  } catch(err) {
    logger.error(err);
  }
}

function saveStates(modulesPath) {
  var states = {};
  for (var key in mapByNamespace) {
    if (!mapByNamespace[key].isNamespace) states[key] = mapByNamespace[key]._state;
  }
  var str = JSON.stringify(states, null, 2);
  fs.writeFileSync( path.join(modulesPath, 'modules.json'), str );
}

function loadModule(ModuleClass, name, abspath, parentMod) {
  try {
    if (!fs.statSync(abspath).isDirectory()) return;
  } catch (err) {
    logger.error('Error loading module "%s". Invalid path: %s.', name, abspath);
  }
  var files;
  var mod = new ModuleClass({name:name, path:abspath});
  if (parentMod) parentMod.add(mod);
  
  // Try to find main js file
  var modmain;
  // First by reading package.json
  var fp = path.join(mod.path, 'package.json');
  if (fs.existsSync(fp)) {
    try {
      mod._meta = require(fp);
      modmain = mod._meta.main;
      //if (modinfo.name) mod.name = modinfo.name;
    } catch(err) {
      logger.error('Error loading the module description file: %s', fp);
    }
  }
  if (moduleSettings && 'object' === typeof moduleSettings[mod.namespace]) merge(mod._meta, moduleSettings[mod.namespace]);
  // If package.json is not found or does not contain "main", read index.js
  if (!modmain) {
    var mnames = ['index.js', mod.name + '.js'];
    mnames.some(function(mname) {
      if (fs.existsSync(path.join(mod.path, mname))) {
        modmain = mname;
        return true;
      }
    });
  }
  
  // Check if it is a valid module
  if (modmain) {
    try {
      mod._setMain(require(path.join(mod.path, modmain)));
      if (!(mod.name in mapByName)) mapByName[mod.name] = mod;
      if (!(mod.namespace in mapByNamespace)) mapByNamespace[mod.namespace] = mod;
      // Automatically load submodules from directories under the `modules` subdirectory
      var smpath = path.join(mod.path, 'modules');
      files = [];
      try { files = fs.readdirSync(smpath); } catch(err) {}
      files.forEach(function(submod){loadModule(ModuleClass, submod, path.join(smpath, submod), mod);});
      
      // Automatically load submodules defined in package.json
      var submodules = mod.meta('submodules');
      if (Array.isArray(submodules)) {
        submodules.forEach(function(submod){loadModule(ModuleClass, path.basename(submod), path.join(mod.path, submod), mod);});
      }
    } catch(err) {
      logger.error('Error loading module "%s". Cannot find or parse %s. Check for errors in the file or if "main" property in package.json is set correctly.', mod.path, modmain);
      logger.debug(err.stack);
    }
  } else {
    // not a module, must be a module namespace/grouping
    mod.flagAsGroup();
    files = fs.readdirSync(mod.path);
    files.forEach(function(submod){loadModule(ModuleClass, submod, path.join(mod.path, submod), mod);});
  }
  
  return mod;
}
var methodKey = '_method';
function methodOverride(req, res, next) {
  req.originalMethod = req.originalMethod || req.method;
  if (req.query && methodKey in req.query) {
    req.method = req.query[methodKey].toUpperCase();
  } else if (req.headers['x-http-method-override']) {
    req.method = req.headers['x-http-method-override'].toUpperCase();
  }
  next();
}

var moduleManager = module.exports = function(options) {
  options = options || {};
  options.modules = options.modules || {};
  options.viewEngines = options.viewEngines || {};
  options.paths = options.paths || {};
  options.paths.statics = options.paths.statics || [];
  moduleSettings = options.modules;
  settings = moduleSettings[''] || {};
  //var routeManagers = options.routeManagers || ['admin','main'];
  moduleManager.createLogger = options.createLogger || jsx.createLogger;
  if (moduleManager.createLogger) logger = moduleManager.createLogger(module);
  moduleManager.views.viewType = settings.viewType || 'basic';
  moduleManager.parseBody = require('./helper.controller').parseBody;
  moduleManager.parseBodyUpload = express.bodyParser({ keepExtensions: true, uploadDir: options.paths.tempUpload });
  moduleManager.parseMultipart = express.multipart({ keepExtensions: true, uploadDir: options.paths.tempUpload });
  var appRootPath = path.dirname(require.main.filename);
  var modulesPath = path.resolve(appRootPath, options.paths.modules || 'modules');
  
  var app = moduleManager.app = express();
  app.configure(function(){
    var key;
    var cssMiddleware = require('less-middleware');
    if (options.behindProxy) app.enable('trust proxy');
    app.set('config', options);
    if (options.paths.views) app.set('views', path.resolve(appRootPath, options.paths.views));
    app.set('view engine', options.viewEngine || 'ejs');
    //if (!options.viewEngines[app.get('view engine')]) app.engine('ejs', require('ejs'));
    for (key in options.viewEngines) app.engine(key, require(options.viewEngines[key]));
    app.use(express.favicon());
    if (options.env && ('function' === typeof options.env[app.settings.env])) options.env[app.settings.env](app, express);
    //app.use(moduleManager.parseBody);
    app.use(methodOverride);
    app.use(express.cookieParser(options.cookieSecret || 'dEfAuLtC00kiEsECret'));
    app.use(express.session());
    app.use(function(req, res, next){
      if (req.session.user) res.locals._user = req.session.user;
      next();
    });
    app.locals._user = null;
    //attach middleware to detect request for various response format (such as html, json), and put it in request.format
    app.use(formatResolver());
    //app.use(express.bodyParser());
    app.use(app.router);
    options.paths.statics.forEach(function(p) {
      var rpath = path.resolve(appRootPath, p);
      app.use(cssMiddleware({ src: rpath }));
      app.use(express.static(rpath));
    });
  });
  
  //monkey patch: add response.respond to look up the views provided in modules
  app.response.respond = function(options, fn) {
    options = options || {};
    var res = this;
    var req = res.req;
    var controller = options._controller = options._controller || res.locals._entity.controller || {};
    options._controllerName = controller.name || '';
    var format = req.format || controller._defaultFormat || 'html';
    var renderers = controller._renderers || viewRenderers;
    if (!(format in renderers)) format = 'default';
    renderers[format](res, options, fn);
  };
  
  moduleManager.server = http.createServer(app);
  
  // Load all the modules
  var ExModule = require('./ExModule')(moduleManager);
  
  var rootModule = moduleManager._rootModule = loadModule(ExModule, 'root', modulesPath);
  //if (logger) logger.debug(rootModule);
  // fix parent-child relationship
  for (var key in mapByNamespace) {
    var m = mapByNamespace[key];
    var parentName = m.meta('parent');
    if (parentName) {
      var parent = mapByNamespace[parentName];
      if (parent) {
        parent.add(m);
        mapByNamespace[m.namespace] = m;
        delete mapByNamespace[key];
      }
    }
  }
  
  if (loadStates(modulesPath)) ExModule.stateModified(true);
  
  process.on('exit', function() {
    if (ExModule.stateModified()) saveStates(modulesPath);
  });  
  
  return moduleManager;
};

moduleManager.start = function() {
  // Initialise loaded modules
  moduleManager._rootModule._init(true);
  //debug urls
  //for (key in mapByNamespace) console.log(mapByNamespace[key]._namedRoutes);
  var app = moduleManager.app;
  var config = app.get('config');
  moduleManager.server.listen(config.port, function(){
    logger.info("%s version %s listening on port %d in %s mode", config.appName, config.appVersion, config.port, app.settings.env);
  });
};

moduleManager.install = function(mods, cb) {
  if (mods && mods.length > 0) {
    forEachSerial(mods, function(name, done){ findModule(name).install(done); }, cb);
  } else {
    moduleManager._rootModule.installAll(cb);
  }
};

moduleManager.uninstall = function(mods, cb) {
  if (mods && mods.length > 0) {
    forEachSerial(mods, function(name, done){ findModule(name).uninstall(done); }, cb);
  } else {
    moduleManager._rootModule.uninstallAll(cb);
  }
};

moduleManager.enable = function(mods, cb) {
  if (mods && mods.length > 0) {
    forEachSerial(mods, function(name, done){ findModule(name).enable(done); }, cb);
  } else {
    moduleManager._rootModule.enableAll(cb);
  }
};

moduleManager.disable = function(mods, cb) {
  if (mods && mods.length > 0) {
    forEachSerial(mods, function(name, done){ findModule(name).disable(done); }, cb);
  } else {
    moduleManager._rootModule.disableAll(cb);
  }
};

moduleManager['debug-modules'] = function() {
  jsx.algorithm.dfsTree(moduleManager._rootModule, 
    function(mod) {
      var installed = mod.isInstalled ? 'yes' : 'no';
      var enabled = mod.isEnabled ? 'yes' : 'no';
      console.log('{%s} installed: %s, enabled: %s', mod.namespace, installed, enabled);
    } , function(mod) { return mod.modules; });
};

moduleManager.controllers = require('./controllers');
moduleManager.views = require('./views');
moduleManager.helper = {};
moduleManager.helper.controller = require('./helper.controller');
moduleManager.helper.view = require('./helper.view');

moduleManager.createController = createController;
moduleManager.findByInterface = findByInterface;
moduleManager.findByName = findByName;
moduleManager.findByNamespace = findByNamespace;
/** Retrieve a loaded module 
 * @method getModule
 */
moduleManager.module = getModule;
moduleManager.method = getMethod;
moduleManager.mount = mount;
moduleManager.resolveView = resolveView;
//moduleManager.formatResolver = require('./format_resolver');
//moduleManager.dynamicStatic

function findByInterface(name) {
  var mname = settings.interfaceProviders[name];
  return findModule(mname);
}

function findByName(name) {
  return mapByName[name];
}

function findByNamespace(name) {
  return mapByNamespace[name];
}

function findModule(name) {
  return findByNamespace(name) || findByName(name);
}

/** Find a module based on name or namespace from the set of managed modules.
 * If there is more than one module with the same name, only the firstly loaded module is returned.
 * @param {string} name A name or namespace
 * @returns {ExModule} The module object with the specified name or namespace
 */
function getModule(name) {
  if (typeof name === 'object') return name;
  var m = findModule(name);
  if (!m) logger.error('Module does not exists: [%s]', name);
  if (m.isEnabled) return m;
  else logger.error('Module is inactive: [%s]', name);
  //m.init();
}

function createController(name) {
  return new moduleManager.controllers.Base({name:name});
}

  //setup locals and  detect attached modules
function detectModule(req, res, next){
  var entity = this;
  res.locals._entity = entity || {};
  res.locals._ = new moduleManager.helper.view(entity);
  res.locals._module = entity.owner || {};
  res.locals._moduleName = res.locals._module.name || '';
  res.locals._moduleNamespace = res.locals._module.namespace || '';
  res.locals._actionName = entity.actionName || '';
  res.locals._path = req.path;
  //console.log(entity.owner.name);
  //console.log(mapByRoute);
  //console.log(req.route.path);
  next();
}

function attachEntity(entity) {
  return function() {
    detectModule.apply(entity, arguments);
  };
}

/**
 * params: module.owner, parent, method route
 */
//function mount(method, route, ownerModule, parentModule, callbacks) {
function mount(method, route, entity, callbacks) {
  if (!callbacks) {
    callbacks = entity;
    entity = undefined;
  }
  if (!route) route = '/'; // if route is an empty string, mount as root
  if (entity) {
    //console.log(entity.parent.name);
    //if (!entity.parent.isReady) throw new Error('Incorrect initialization sequence for: ' + method + ' ' + route);
    //parentModule.init(); //ensure parent module has been initialize;
    //mapByRoute[route] = entity;
    var entityIdentifier = entity.toString();
    if (entity.actionName) {
      entity.parent._namedRoutes[entityIdentifier] = route;
      entity.owner._namedRoutes[entityIdentifier] = route;
    }
    //entity.parent._mergeInjectedHandlers(entityIdentifier, callbacks);
    //entity.parent.beforeExternalMount(entity.toString()).forEach(function(item){
    //  moduleManager.app[item.method](route + item.route, item.callbacks);
    //});
    //if (entity.parent !== entity.owner.parent) entity.owner._event.emit('beforeExternalMount', method, route, entity);
  }
  entity.parent._event.emit('beforeMount', method, route, entity);
  //if (entity.owner.name==='experiment') callbacks.unshift(express.bodyParser());
  //callbacks.forEach(function(cb){console.log(cb.toString())});
  //function(req,res,next){console.log(callbacks); next()}
  moduleManager.app[method](route, attachEntity(entity), callbacks);
  logger.debug('mounted route: [%s] %s %s', entity, method, route);
}

function resolveView(name) {
  var viewDir = moduleManager.app.get('views');
  var ext = path.extname(name);
  if (!ext) { 
    ext = '.' + moduleManager.app.get('view engine');
    name += ext;
  }
  var viewPath = path.resolve(viewDir, name);
  if (path.exists(viewPath)) return viewPath;
  viewPath = path.join(path.dirname(viewPath), path.basename(viewPath, ext), 'index' + ext);
  if (path.exists(viewPath)) return viewPath;
}

function getMethod(name) {
  if (!name) return;
  var tokens = name.split('.');
  var obj = moduleManager;
  while (tokens.length) {
    var key = tokens.shift();
    if (tokens.length === 0 && typeof obj[key] === 'function') return obj[key].bind(obj);
    var nextObj = obj[key];
    if (typeof obj.module === 'function') nextObj = obj.module(key) || nextObj;
    if (nextObj) obj = nextObj;
    else return;
  }
}