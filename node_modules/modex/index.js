"use strict";
/**
 * Automatic modules loader based on file naming convention.
 * This module will traverse `./modules` directory, relative to the app.js.
 * usage: require('modex')(app, options);
 * options :
 *   path - relative path of the directory that contains all the modules. Default: 'modules'
 *   moduleSettings - an object that contains optional settings for modules.
 * Public API:
 * app, logger, findByInterface, findByName, findByNamespace, controllers, views
 */
var path = require('path');
var fs = require('fs');
var jsx = require('jsx');
var viewRenderers = require('./views').renderers;

var mapByName = {};
var mapByNamespace = {};
//var mapByRoute = {};
//var viewsDir = path.join(__dirname, 'views');
var moduleSettings;
var settings;
var logger;
var devenv = false;

/// Add all properties in source to target. Existing property will be replaced.
function extend(target, source) {
  var key, val, tval;
  for (key in source) {
    val = source[key];
    if (typeof val === 'object' && Object.getPrototypeOf(val) === Object.prototype) {
      tval = target[key];
      if (typeof tval !== 'object' || Object.getPrototypeOf(tval) !== Object.prototype) {
        tval = target[key] = {};
      }
      extend(tval, val);
    } else {
      target[key] = val;
    }
  }
}

function loadStates(modulesPath) {
  var key;
  try {
    var states = require( path.join(modulesPath, 'modules.json') );
    for (key in states) {
      if (key in mapByNamespace) mapByNamespace[key]._load(states[key]);
    }
    for (key in mapByNamespace) {
      if (!(key in states)) return true;
    }  
  } catch(err) {
    logger.error(err);
  }
}

function saveStates(modulesPath) {
  var states = {};
  for (var key in mapByNamespace) {
    if (!mapByNamespace[key].isNamespace) states[key] = mapByNamespace[key]._state;
  }
  var str = JSON.stringify(states, null, 2);
  fs.writeFileSync( path.join(modulesPath, 'modules.json'), str );
}

function loadModule(ModuleClass, name, abspath, parentMod) {
  try {
    if (!fs.statSync(abspath).isDirectory()) return;
  } catch (err) {
    logger.error('Error loading module "%s". Invalid path: %s.', name, abspath);
  }
  var files;
  var mod = new ModuleClass({name:name, path:abspath});
  if (parentMod) parentMod.add(mod);
  
  // Try to find main js file
  var modmain;
  // First by reading package.json
  var fp = path.join(mod.path, 'package.json');
  if (fs.existsSync(fp)) {
    try {
      mod._meta = require(fp);
      modmain = mod._meta.main;
      //if (modinfo.name) mod.name = modinfo.name;
    } catch(err) {
      logger.error('Error loading the module description file: %s', fp);
    }
  }
  if (moduleSettings) extend(mod._meta, moduleSettings[mod.namespace]);
  // If package.json is not found or does not contain "main", read index.js
  if (!modmain) {
    var mnames = ['index.js', mod.name + '.js'];
    mnames.some(function(mname) {
      if (fs.existsSync(path.join(mod.path, mname))) {
        modmain = mname;
        return true;
      }
    });
  }
  
  // Check if it is a valid module
  if (modmain) {
    try {
      mod._setMain(require(path.join(mod.path, modmain)));
      if (!(mod.name in mapByName)) mapByName[mod.name] = mod;
      if (!(mod.namespace in mapByNamespace)) mapByNamespace[mod.namespace] = mod;
      // Automatically load submodules from directories under the `modules` subdirectory
      var smpath = path.join(mod.path, 'modules');
      files = [];
      try { files = fs.readdirSync(smpath); } catch(err) {}
      files.forEach(function(submod){loadModule(ModuleClass, submod, path.join(smpath, submod), mod);});
      
      // Automatically load submodules defined in package.json
      var submodules = mod.meta('submodules');
      if (Array.isArray(submodules)) {
        submodules.forEach(function(submod){loadModule(ModuleClass, path.basename(submod), path.join(mod.path, submod), mod);});
      }
    } catch(err) {
      logger.error('Error loading module "%s". Cannot find or parse %s. Check for errors in the file or if "main" property in package.json is set correctly.', mod.path, modmain);
      if (devenv) logger.debug(err.stack);
    }
  } else {
    // not a module, must be a module namespace/grouping
    mod.flagAsGroup();
    files = fs.readdirSync(mod.path);
    files.forEach(function(submod){loadModule(ModuleClass, submod, path.join(mod.path, submod), mod);});
  }
  
  return mod;
}

var moduleManager = module.exports = function(app, options) {
  moduleManager.createLogger = app.get('logger') || jsx.createLogger;
  if (moduleManager.createLogger) logger = moduleManager.createLogger(module);
  
  options = options || {};
  moduleSettings = options.moduleSettings;
  settings = moduleSettings[''];
  //var routeManagers = options.routeManagers || ['admin','main'];
  if (app.get('env') === 'development') devenv = true;
  moduleManager.app = app;
  moduleManager.views.viewType = settings.viewType || 'basic';
  
  //monkey patch: add response.respond to look up the views provided in modules
  app.response.respond = function(options, fn) {
    options = options || {};
    var res = this;
    var req = res.req;
    var controller = options._controller = options._controller || res.locals._entity.controller || {};
    options._controllerName = controller.name || '';
    var format = req.format || controller._defaultFormat || 'html';
    var renderers = controller._renderers || viewRenderers;
    if (!(format in renderers)) format = 'default';

    renderers[format](res, options, fn);
  };
  
  // Load all the modules
  var ExModule = require('./ExModule')(moduleManager);
  var appRootPath = path.dirname(require.main.filename);
  var modulesPath = path.join(appRootPath, options.path || 'modules');
  
  var rootModule = loadModule(ExModule, 'root', modulesPath);
  //if (logger) logger.debug(rootModule);
  // fix parent-child relationship
  for (var key in mapByNamespace) {
    var m = mapByNamespace[key];
    var parent = m.meta('parent');
    if (parent) {
      parent = mapByNamespace[parent];
      if (parent) {
        parent.add(m);
        mapByNamespace[m.namespace] = m;
      }
    }
  }
  
  if (loadStates(modulesPath)) ExModule.stateModified(true);
  // Initialise loaded modules
  rootModule._init(true);
  //debug urls
  //for (key in mapByNamespace) console.log(mapByNamespace[key]._namedRoutes);
  
  process.on('exit', function() {
    if (ExModule.stateModified()) saveStates(modulesPath);
  });  
  
  return moduleManager;
};

moduleManager.controllers = require('./controllers');
moduleManager.views = require('./views');
moduleManager.helper = {};
moduleManager.helper.controller = require('./helper.controller');
moduleManager.helper.view = require('./helper.view');

moduleManager.createController = createController;
moduleManager.findByInterface = findByInterface;
moduleManager.findByName = findByName;
moduleManager.findByNamespace = findByNamespace;
moduleManager.module = getModule;
moduleManager.method = getMethod;
moduleManager.mount = mount;
moduleManager.resolveView = resolveView;
moduleManager.formatResolver = require('./format_resolver');
//moduleManager.dynamicStatic

function findByInterface(name) {
  var mname = settings.interfaceProviders[name];
  return findModule(mname);
}

function findByName(name) {
  return mapByName[name];
}

function findByNamespace(name) {
  return mapByNamespace[name];
}

function findModule(name) {
  return findByNamespace(name) || findByName(name);
}

function getModule(name) {
  if (typeof name === 'object') return name;
  var m = findModule(name);
  if (!m) if (logger) logger.error('Module does not exists: [%s]', name);
  if (m.isEnabled) return m;
  else if (logger) logger.error('Module is inactive: [%s]', name);
  //m.init();
}

function createController(name) {
  return new moduleManager.controllers.Base({name:name});
}

  //setup locals and  detect attached modules
function detectModule(req, res, next){
  var entity = this;
  res.locals._entity = entity || {};
  res.locals._ = new moduleManager.helper.view(entity);
  res.locals._module = entity.owner || {};
  res.locals._moduleName = res.locals._module.name || '';
  res.locals._moduleNamespace = res.locals._module.namespace || '';
  res.locals._actionName = entity.actionName || '';
  //console.log(mapByRoute);
  //console.log(req.route.path);
  next();
}

function attachEntity(entity) {
  return function() {
    detectModule.apply(entity, arguments);
  }
}

/**
 * params: module.owner, parent, method route
 */
//function mount(method, route, ownerModule, parentModule, callbacks) {
function mount(method, route, entity, callbacks) {
  if (!callbacks) {
    callbacks = entity;
    entity = undefined;
  }
  if (!route) route = '/'; // if route is an empty string, mount as root
  if (entity) {
    //console.log(entity.parent.name);
    //if (!entity.parent.isReady) throw new Error('Incorrect initialization sequence for: ' + method + ' ' + route);
    //parentModule.init(); //ensure parent module has been initialize;
    //mapByRoute[route] = entity;
    var entityIdentifier = entity.toString();
    if (entity.actionName) {
      entity.parent._namedRoutes[entityIdentifier] = route;
      entity.owner._namedRoutes[entityIdentifier] = route;
    }
    //entity.parent._mergeInjectedHandlers(entityIdentifier, callbacks);
    //entity.parent.beforeExternalMount(entity.toString()).forEach(function(item){
    //  moduleManager.app[item.method](route + item.route, item.callbacks);
    //});
    //if (entity.parent !== entity.owner.parent) entity.owner._event.emit('beforeExternalMount', method, route, entity);
  }
  entity.parent._event.emit('beforeMount', method, route, entity);
  
  moduleManager.app[method](route, attachEntity(entity), callbacks);
  logger.debug('mounted route: [%s] %s %s', entity, method, route);
}

function resolveView(name) {
  var viewDir = moduleManager.app.get('views');
  var ext = path.extname(name);
  if (!ext) { 
    ext = '.' + moduleManager.app.get('view engine');
    name += ext;
  }
  var viewPath = path.resolve(viewDir, name);
  if (path.exists(viewPath)) return viewPath;
  viewPath = path.join(path.dirname(viewPath), path.basename(viewPath, ext), 'index' + ext);
  if (path.exists(viewPath)) return viewPath;
}

function getMethod(name) {
  if (!name) return;
  var tokens = name.split('.');
  var obj = moduleManager;
  while (tokens.length) {
    var key = tokens.shift();
    if (tokens.length === 0 && typeof obj[key] === 'function') return obj[key].bind(obj);
    var nextObj = obj[key];
    if (typeof obj.module === 'function') nextObj = obj.module(key) || nextObj;
    if (nextObj) obj = nextObj;
    else return;
  }
}