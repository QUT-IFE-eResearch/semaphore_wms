"use strict";
/*
 * Express.js modular framework.
 * A module helper class to initialize an enabled module.
 */

var fs = require('fs');
var path = require('path');
var cDef = require('./controllers/defaults');
var express = require('express');
var eachFileInDir = require('./utils').eachFileInDir;
var modex;

var Mod = function(xmod) {
  this._xmod = xmod;
  var mod = this._xmod.main;
  mod.models = mod.models || {};
  mod.views = mod.views || {};
  mod.controllers = mod.controllers || {};
  mod.viewers = mod.viewer || {};
  mod.viewRenderers = mod.viewRenderers || {};
};

exports = module.exports = function(_modex) {
  modex = _modex;
  Mod.prototype.app = Mod.app = modex.app;
  Mod.prototype.manager = modex;
  return Mod;
};

/** Returns the route full path of this module */
Object.defineProperties(Mod.prototype, {
  fullRoute : { get : function () { return this._xmod.getRoutePath(); }, enumerable : true }
});

function resolveBase(params, xmod) {
  var routeBase;
  var modBase = xmod;
  if (typeof params.route === 'string') {
    routeBase = params.route;
  } else {
    if (params.interface) {
      modBase = modex.findByInterface(params.interface);
    } else if (params.module) {
      if (typeof params.module === 'string') modBase = modex.findByNamespace(params.module);
      else modBase = params.module;
    }
    if (!modBase) modBase = xmod;
    routeBase = modBase.getRoutePath();
  }
  if (routeBase[routeBase.length-1] === '/') routeBase = routeBase.slice(0,-1);
  return {route:routeBase, module:modBase};
}


Mod.prototype.setMeta = function(name, value) {
  if (!this._xmod.meta[name]) this._xmod.meta[name] = value;
}

Mod.prototype.getMeta = function(name) {
  return this._xmod.meta[name];
}

/**
 * Mount the handler to the route: module_base_route/route
 * method : String (required) : The HTTP method to be handled.
 * route : String (required) : The relative route.
 * params:
 *   label : String : If specified, the parent module will be notified that the handler has been added.
 *   Specify either one these, resolved in order of: route | interface | module
 *   interface | module : Request to adds the controller to the specified interface or module (namespaced), if exists. Default will mount the controller to the parent module.
 *   route : String : An absolute base route path that will be prepended to the route. Ie: params.route/route
 */
/** params : (Optional)*/
Mod.prototype.addHandler = function addHandler(method, route, params, callbacks) {
  if (!callbacks) {
    callbacks = params;
    params = {};
  }
  try {
    var xmod = this._xmod;
    var base = resolveBase(params, xmod);
    route = (base.route + route).replace(/^\/+/, '/');
    if (params.label) base.module.registerResource(xmod, params.label, route);
    modex.registerRoute(method, route, xmod, base.module, callbacks);
    return route;
  } catch (e) {
    modex.logger.error('Initialize module [%s]: addHandler() : %s', xmod.namespace, e);
  }
};

/**
 * Mount the controller to the route: module_base_route/controller_name
 * controller : String | Object (required) : The controller object or path to the js file, relative to the module dir.
 * params:
 *   name : String (auto) : Name of the controller, will be used in the routing path. If not specified, the name of the js file will be used. 
       Use string '/' to mount the controller as the default module handler.
 *   Specify either one these, resolved in order of: route | interface | module
 *   interface | module : Request to adds the controller to the specified interface or module (namespaced), if exists. Default will mount the controller to the parent module.
 *   route : String : An absolute base route path to mount the controller to, instead of the module base route. Ie: baseRoute/name
 *   handler : String : A handler in the specified interface/module
 *   layout : String : Absolute or relative path to layout template file.
 */
Mod.prototype.addController = function addController(controller, params) {
  if (typeof params !== 'object') params = {};
  var xmod = this._xmod;
  var mod = xmod.main;
  var fullpath;
  if (!mod.controllers) mod.controllers = {};
  if (typeof controller === 'string') {
    // Resolve path and load controller object
    if (!params.name && path.basename(controller, '.js') === 'index') params.name = '/';
    fullpath = path.resolve(xmod.path, controller);
    controller = require(fullpath);
  } else if (typeof controller !== 'object') {
    throw new Error('Error in initializing module [%s]: controller must be an object or a string.', xmod.namespace);
  }
  var controllerName = controller.controllerName;
  // Automatic naming based on object property or filename
  if (!params.name) {
    if (controller.controllerName) params.name = controller.controllerName;
    else if (fullpath) params.name = path.basename(fullpath, '.js');
    else throw new Error('Error in initializing module [%s]: Please specify a name for the controller.', xmod.namespace);
  }
  controller.controllerName = params.name;
  if (params.name === '/') {
    controller.controllerName = path.basename(xmod.route);
    params.name = '';
  }
  
  // Add the controller
  mod.controllers[params.name] = controller;
  if (typeof controller._init === 'function') controller._init();
  // Resolve route base path
  var base = resolveBase(params, xmod);
  var routeBase = base.route;
  if (params.name) routeBase = routeBase + '/' + params.name;
  // Notify the parent module
  if (!params.name) params.name = xmod.name;
  params.label = params.label || (params.name[0].toUpperCase() + params.name.slice(1));
  base.module.registerResource(xmod, params.label, routeBase);
  // Add to express route
  var action, callbacks;
  function processCallbacks(a) {
    if (Array.isArray(a)) {
      a.forEach(function(b){callbacks.push(b.bind(controller));});
    } else if (typeof a === 'function') {
      callbacks.push(a.bind(controller));
    }
  }
  for (var actionName in controller) {
    action = controller[actionName];
    if (actionName[0] !== '_' && typeof action === 'function') {
      callbacks = [];
      [controller[actionName+'_pre'], action, controller[actionName+'_post']].forEach(processCallbacks);
      if (callbacks.length > 0) {
        var method = controller[actionName+'_method'] || 'get';
        var route;
        if (controller[actionName+'_absroute']) {
          route = controller[actionName+'_absroute'];
        } else {
          var actionRoute = controller[actionName+'_route'];
          if (typeof actionRoute === 'string') route = actionRoute;
          else if (typeof cDef.routes[actionName] === 'string') route = cDef.routes[actionName] 
          else route = '/' + actionName;
          route = routeBase + route;
        }
        //modex.app[method](route, callbacks);
        modex.registerRoute(method, route, xmod, base.module, callbacks);
      }
    }
  }
  
};

// Load all js files from a directory. Non recursive
Mod.prototype.addControllers = function addControllers(pathToDir, params) {
  var basePath = path.resolve(this._xmod.path, pathToDir);
  var self = this;
  eachFileInDir(basePath, function(name, fullpath) {
    var opt;
    if (params) {
      opt = {};
      if (params.route) opt.route = params.route;
      if (params.interface) opt.interface = params.interface;
      if (params.module) opt.module = params.module;
    }
    self.addController(fullpath, opt);
  });
  //    throw new Error('Error in initializing module [%s]: Error loading directory: %s', this._xmod.namespace, fullPath);
};

Mod.prototype.addDefaultController = function addDefaultController(pathOrController) {
  this.addController(pathOrController, {name:'/'});
};

/**
 * Load the model to be made available to other modules
 * model : String | Object (required) : The model object or path to the js file, relative to the module dir.
 * params:
 *   name : String : Name of the model. If omitted, the model.modelName property will be used.
 */
Mod.prototype.addModel = function addModel(model, params) {
  if (typeof params !== 'object') params = {};
  var xmod = this._xmod;
  var mod = xmod.main;
  var filepath;
  if (!mod.models) mod.models = {};
  if (typeof model === 'string') {
    filepath = model;
    // Resolve path and load model object
    model = path.resolve(xmod.path, model);
    model = require(model);
  } else if (typeof model !== 'object') {
    throw new Error('Error in initializing module [%s]: model must be an object or a string.', xmod.namespace);
  }
  // Automatic naming based on modelName and filename
  if (!params.name) {
    if (model.modelName) params.name = model.modelName;
    else params.name = path.basename(filepath, '.js');
  }
  mod.models[params.name] = model;
};

Mod.prototype.addModels = function addModels(pathToDir) {
  var basePath = path.resolve(this._xmod.path, pathToDir);
  var self = this;
  eachFileInDir(basePath, function(name, fullpath) { self.addModel(fullpath); } );
};

/** Returns the route full path of the specified module */
Mod.prototype.moduleRoute = function moduleRoute(moduleName) {
  var mod;
  if (moduleName) mod = modex.findByNamespace(moduleName);
  if (!mod) throw new Error('Module not found.');
  return mod.getRoutePath();
};

/** Returns the route full path of the specified interface */
Mod.prototype.interfaceRoute = function interfaceRoute(name) {
  if (name) {
    var mod = modex.findByInterface(name);
    if (mod) return mod.getRoutePath();
  }
  throw new Error('Interface not found.');
};

Mod.prototype.addView = function addView(pathToTemplate, name) {
  var xmod = this._xmod;
  var mod = xmod.main;
  var fullpath = path.resolve(xmod.path, pathToTemplate);
  //var ext = path.extname(pathToTemplate);
  //if (!template) { // load template from file
  //  template = fs.readFileSync(fullpath,'utf8');
  //}
  if (!name) name = path.basename(pathToTemplate);
  if (!mod.views) mod.views = {};
  //if (!(name in mod.views)) mod.views[name] = {};
  //extension without dot
  //ext = ext.slice(1);
  mod.views[name] = fullpath;
};

Mod.prototype.addViews = function addViews(pathToDir) {
  var basePath = path.resolve(this._xmod.path, pathToDir);
  var self = this;
  eachFileInDir(basePath, function(name, fp) {
    var name = path.relative(basePath, fp);
    self.addView(fp, name);
  }, true);
};

Mod.prototype.addStatic = function(pathToDir, name) {
  var basePath = path.resolve(this._xmod.path, pathToDir);
  var staticPath = path.resolve(this._xmod.path, pathToDir)
  if (!name) name = path.basename(pathToDir);
  name = this._xmod.route + '/' + name;
  modex.app.use(name, express.static(staticPath));
};

Mod.prototype.setResourceHandler = function(callback) {
  this._xmod.main.onRegisterResource = callback;
};

Mod.prototype.setLocalsHandler = function(callback) {
  this._xmod.main.prepareViewLocals = callback;
};

Mod.prototype.setPartialView = function(name, value) {
  modex.helper.view.setPartial(name, value);
};

Mod.prototype.getModule = function(name) {
  return modex.module(name).main;
};

Mod.prototype.routePath = routePath;

function routePath(relativeRoute) {
//  var r = this.fullRoute;
//  if (r[r.length - 1] === '/' && relativeRoute[0] === '/') return r + relativeRoute.slice(1);
//  else return r + relativeRoute;
  return (this.fullRoute + relativeRoute).replace(/^\/+/, '/');
}