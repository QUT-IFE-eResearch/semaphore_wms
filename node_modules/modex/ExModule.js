"use strict";
/*
 * A helper class for Express.js modular framework.
 * This class represent a module.
 */

var path = require('path');
var EventEmitter = require('events').EventEmitter;
var express = require('express');
var jsx = require('jsx');
var cDef = require('./controllers/defaults');
var utils = require('./utils');
var eachFileInDir = utils.eachFileInDir;
var isDir = utils.isDir;
var merge = utils.merge;
var urlJoin = utils.urlJoin;
var forEachSerial = utils.forEachSerial;

var FLAG_INSTALLED = 0x1; // 01
var FLAG_ENABLED = 0x2;   // 10
var stateModified = false;
var logger;
var moduleManager;

module.exports = function(mm) {
  moduleManager = mm;
  logger = moduleManager.createLogger(module);
  return ExModule;
};

function Entity(owner, parent, controller, actionName) {
  if (!parent || owner === parent) parent = owner.parent;
  this.owner = owner;
  this.parent = parent;
  this.controller = controller;
  this.controllerName = controller.name || '';
  this.actionName = actionName || '';
}
Entity.prototype.toString = function() {
  var str = this.owner.namespace;
  if (this.controller && this.controller.name) str += '.' + this.controllerName;
  if (this.actionName) str += '.' + this.actionName;
  return str;
};

function ExModule(opt) {
  Object.defineProperties(this, {
    name : {value:opt.name, enumerable: true},
    path : {value:opt.path, enumerable: true}, //filepath
    parent : {value:opt.parent, enumerable: true, writable: true},
    modules : {value:{}, enumerable: true},
    _meta : {value:{}, writable: true},
    _data : {value:{}},
    _externalHandlers : {value:{}},
    _namedRoutes : {value:{}},
    _routesIndex : {value:{}},
    _event : {value:new EventEmitter()},
    _state : {value:0x0, writable: true}, // 0 = not installed, 1 = installed but disabled, 3 = installed and enabled
    _autoMountControllers : {value:true, writable: true},
    _isGroup : {value:false, writable: true},
    _isReady : {value:false, writable: true}
  });
}

ExModule.stateModified = function(val) {
  if (typeof val === 'boolean') stateModified = val;
  return stateModified;
};

ExModule.isEnabled = function(state) {
  return state & FLAG_ENABLED;
};

function hasInstalledSubmodule(mod) {
  for (var key in mod.modules) {
    if (mod.modules[key].isInstalled) return true;
  }
  return false;
}

function hasEnabledSubmodule(mod) {
  for (var key in mod.modules) {
    if (mod.modules[key].isEnabled) return true;
  }
  return false;
}

/** Calculates the absolute route path of this module */
ExModule.prototype.getRoutePath = function getRoutePath() {
  if (!this._routePath) {
    var parentPath = '';
    var relPath = this.meta('route') || '';
    if (!relPath || relPath[0] !== '/') {
      parentPath = '/';
      if (this.parent) {
        parentPath = this.parent.getRoutePath();
        if (parentPath[parentPath.length-1] !== '/') parentPath = parentPath + '/';
      }
    }
    this._routePath = parentPath + relPath;
  }
  return this._routePath;
};

Object.defineProperties(ExModule.prototype, {
  namespace : { get : function() { return this.parent ? ( this.parent.namespace ? this.parent.namespace + '.' + this.name : this.name) : '';}, enumerable : true },
//  route : { get : function() { return this.meta.route || this.name; }, set : function(val){ this.meta.route = route; }, enumerable : true },
  fullRoute : { get : ExModule.prototype.getRoutePath, enumerable : true },
  routePath : { get : ExModule.prototype.getRoutePath, enumerable : true },
  methods : { get : function() { return this.main; }, enumerable : true },
  models : { get : function() { return this.main.models; }, enumerable : true },
  views : { get : function() { return this.main.views; }, enumerable : true },
  controllers : { get : function() { return this.main.controllers; }, enumerable : true },
//  manager : { get : function() { return moduleManager; }, enumerable : true },
//  app : { get : function() { return moduleManager.app; }, enumerable : true },
  isInstalled : { get : function() { return this._state & FLAG_INSTALLED; }, enumerable : true },
  isEnabled : { get : function() { return this._state & FLAG_ENABLED; }, enumerable : true },
  isGroup : { get : function() { return this._isGroup; }, enumerable : true },
  isReady : { get : function() { return (this._isGroup || this._isReady); }, enumerable : true },
  hasInstalledSubmodule : { get : function() { return hasInstalledSubmodule(this); }, enumerable : true },
  hasEnabledSubmodule : { get : function() { return hasEnabledSubmodule(this); }, enumerable : true }
});


ExModule.prototype.flagAsGroup = function() {
  this._isGroup = true;
  this._state = FLAG_INSTALLED | FLAG_ENABLED;
  
};

ExModule.prototype.module = function(name) {
  if (typeof name === 'undefined') return this;
  return this.modules[name];
};

ExModule.prototype.controller = function(name) {
  if (typeof name === 'undefined') name = '';
  return this.controllers[name];
};

ExModule.prototype.add = function(submodule) {
  this.modules[submodule.name] = submodule;
  if (submodule.parent) {
    delete submodule.parent.modules[submodule.name];
  }
  submodule.parent = this;
};

function noop(){}

function ensureArguments(options, cb) {
  if (typeof cb !== 'function') {
    if (typeof options === 'function') {
      cb = options;
      options = {};
    } else {
      cb = noop;
    }
  }
  options = options || {};
  return {options:options, cb:cb};
}

ExModule.prototype.install = function(options, cb) {
  var args = ensureArguments(options, cb);
  if (this.isGroup || this.isInstalled || !this.parent.isInstalled) return args.cb();
  try {
    if (this.main && (typeof this.main.install === 'function')) {
      this.main.install(args.options, args.cb);
    }
    this._state |= FLAG_INSTALLED;
    stateModified = true;
    logger.debug("{%s} Installed", this.namespace);
  } catch (err) {
    logger.error("Failed executing install method in module %s", this.namespace);
  }
};

ExModule.prototype.installAll = function(options, cb) {
  var args = ensureArguments(options, cb);
  var children = this.modules;
  this.install(args.options, function(err) {
    if (err) return args.cb(err);
    forEachSerial(Object.keys(children), function(name, done){ children[name].installAll(args.options, done); }, args.cb);
  });
};

ExModule.prototype.installer = function(fn) {
  if (typeof fn === 'function') this.main.install = fn;
};

ExModule.prototype.uninstall = function(options, cb) {
  var args = ensureArguments(options, cb);
  if (this.isGroup || !this.isInstalled || this.hasInstalledSubmodule) return args.cb();
  this.disableAll(function(err){
    if (err) return args.cb(err);
    try {
      if (this.main && ('function' === typeof this.main.uninstall)) this.main.uninstall(args.options, args.cb);
      this._state &= ~FLAG_INSTALLED;
      stateModified = true;
      logger.debug("{%s} Uninstalled", this.namespace);
    } catch (err) {
      if (logger) logger.error("Failed executing uninstall method in module %s", this.namespace);
    }
  });
};

ExModule.prototype.uninstallAll = function(options, cb) {
  var args = ensureArguments(options, cb);
  var self = this;
  forEachSerial(Object.keys(self.modules), function(name, done){ self.modules[name].uninstallAll(args.options, done); }, function(err) {
    if (err) return args.cb(err);
    self.uninstall(options, args.cb);
  });
};

ExModule.prototype.uninstaller = function(fn) {
  if (typeof fn === 'function') this.main.uninstall = fn;
};

ExModule.prototype.enable = function(cb) {
  cb = cb || noop;
  if (this.isGroup || !this.isInstalled || !this.parent.isEnabled || this.isEnabled) {
    process.nextTick(cb); 
    return;
  }
  this._state |= FLAG_ENABLED;
  this._init();
  stateModified = true;
  process.nextTick(cb);
};

ExModule.prototype.enableAll = function(cb) {
  cb = cb || noop;
  var self = this;
  this.enable(function(){
    forEachSerial(Object.keys(self.modules), function(name, done){ self.modules[name].enableAll(done); }, cb);
  });
};

ExModule.prototype.disable = function(cb) {
  cb = cb || noop;
  if (this.isGroup || !this.isEnabled || this.hasEnabledSubmodule) {
    process.nextTick(cb); 
    return;
  }
  this._state &= ~FLAG_ENABLED;
  this._deinit();
  stateModified = true;
  process.nextTick(cb);
};

ExModule.prototype.disableAll = function(cb) {
  cb = cb || noop;
  var self = this;
  forEachSerial(Object.keys(self.modules), function(name, done){ self.modules[name].disableAll(done); }, function() {
    this.disable(cb);
  });
};

function endsWith(str, suffix) {
  return str.indexOf(suffix, str.length - suffix.length) !== -1;
}

function matchKeyByEntity(obj, word){
  var suffix = '$';
  var list = [];
  for (var key in obj) {
    var pattern;
    if (jsx.string.endsWith(key, '.*')) {
      pattern = key.slice(0, -2);
      suffix = '($|\\.\\w+)';
    }
    pattern = pattern.replace(/\*/g, '\\w*');
    pattern = pattern.replace(/\./g, '\\.');
    pattern = '(^|\\w*\\.)' + pattern + suffix;
    var re = new RegExp(pattern);
    if (re.test(word)) list.push(obj[key]);
  }
  return jsx.array.flatten(list);
}

///////////////////////////////////////////////////////////////////////////////////////
///// private apis 

ExModule.prototype._mergeInjectedHandlers = function(entityIdentifier, callbacks) {
  //logger.debug('entityIdentifier: %s', entityIdentifier);
  var handlers = this._externalHandlers;
  var pre = handlers.pre;
  var post = handlers.post;
  var list, i;
  //console.log(callbacks);
  //console.log(pre);
  if (pre) {
    list = matchKeyByEntity(pre, entityIdentifier);
    if (list) for (i=list.length; i--; ) callbacks.unshift(list[i]);
  }
  if (post) {
    list = matchKeyByEntity(post, entityIdentifier);
    if (list) for (i=0; i<list.length; ++i) callbacks.push(list[i]);
  }
  //console.log(callbacks);
};

/** private api */
ExModule.prototype._setMain = function(main) {
  main = main || {};
  Object.defineProperty(this, 'main', {value:main});
  main.models = main.models || {};
  main.views = main.views || {};
  main.controllers = main.controllers || {};
  main.viewers = main.viewer || {};
  main.viewRenderers = main.viewRenderers || {};
};

ExModule.prototype._load = function(state) {
  this._state = state;
  //run constructor if exists
  if (isDir(path.join(this.path, './models'))) this.addModels('./models');
  if (isDir(path.join(this.path, './views'))) this.addViews('./views');
  if (isDir(path.join(this.path, './controllers'))) this.addControllers('./controllers');
    
	if (typeof this.main === 'function') this.main(this, moduleManager, moduleManager.app);
};

/** Mount routes defined by modules */
ExModule.prototype._init = function(recursive) {
  var key;
  logger.debug('try module _init: ' + this.namespace);
  if (this.isEnabled && !this.isReady && this.main) {
    logger.debug('start module _init: ' + this.namespace);
    this._isReady = true;
    var routes = moduleManager.app.routes;
    for (key in routes) {
      this._routesIndex[key] = {start:routes[key].length, count:0};
    }
    
    if (typeof this.main.init === 'function') 
      this.main.init(this, moduleManager, moduleManager.app);
      
    this.mountControllers();
    
    for (key in routes) {
      if (!(key in this._routesIndex)) this._routesIndex[key] = {start:0, count:0};
      this._routesIndex[key].count = routes[key].length - this._routesIndex[key].start;
    }
    logger.debug('end module _init: ' + this.namespace);
  }
  if (recursive) {
    //console.log('submodules of %s:', this.namespace);
    //console.log(this.modules);
    var priorities = [];
    var noprio = [];
    for (key in this.modules) {
      var m = this.modules[key];
      var index = m.meta('priority');
      if (typeof index === 'undefined') {
        noprio.push(m);
      } else {
        if (!priorities[index]) priorities[index] = [];
        priorities[index].push(m);
      }
    }
    priorities.push(noprio);
    var list = jsx.array.flatten(priorities);
    //console.log(list);
    list.forEach(function(m){ 
      m._init(recursive); 
    });
  }
};

/** private apis */
ExModule.prototype._deinit = function() {
  if (!this.isReady) return;
  var routes = moduleManager.app.routes;
  for (var key in this._routesIndex) {
    var index = this._routesIndex[key];
    if (index.count > 0) routes[key].splice(index.start, index.count);
  }
  this._isReady = false;
};


ExModule.prototype.resolveView = function(name, checkParent, options) {
  if (this.isEnabled && typeof this.main === 'function') {
    var viewEngine, viewPath;
    if (name in this.main.views) {
      viewPath = this.main.views[name];
    } else {
      viewEngine = this.meta('viewEngine') || moduleManager.app.get('view engine');
      viewPath = this.main.views[name + '.' + viewEngine];
    }
    if (viewPath) {
      if (options) {
//        options._route = this.getRoutePath();
        if (this.main.prepareViewLocals) this.main.prepareViewLocals(name, options);
      }
      if (name in this.main.viewRenderers) {
        return function(partialView, defaultRender, fn) {
          this.main.viewRenderers[name]({
            viewPath : viewPath,
            partialView : partialView,
            render : defaultRender,
            options : options,
            callback : fn
          });
        };
      }
      return viewPath;
    }
    if (checkParent) {
      if (this.parent) return this.parent.resolveView(name, checkParent, options);
      else return moduleManager.resolveView(name); //lookup the app level views
    }
  }
};

ExModule.prototype.registerResource = function(ownerModule, resourceName, absroute) {
  if (this.isEnabled && this.main && this.main.onRegisterResource) {
    this.main.onRegisterResource(ownerModule, resourceName, absroute);
  }
  if (this.parent) this.parent.registerResource(ownerModule, resourceName, absroute);
};

ExModule.prototype.model = function(name) {
  return this.models[name];
};

ExModule.prototype.method = function(name) {
  return this.methods[name];
};

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////
// Initializer
////////////////////////////////////////////////////////////////////////////////////////////

/** params:{route:'',interface:'',module:''}*/
function resolveBase(params, ownerModule) {
  var routeBase;
  var routeEnd = params.route || params.name || ''; // use name by default if route is undefined
  var modBase;
  if (typeof params.interface === 'string' || params.module) {
    if (typeof params.interface === 'string') {
      modBase = moduleManager.findByInterface(params.interface);
    } else if (params.module) {
      if (typeof params.module === 'string') modBase = moduleManager.module(params.module);
      else modBase = params.module;
    }
    //relative to /target_module_route/own_module_route
    if (modBase) {
      if (routeEnd[0] === '/') routeBase = urlJoin(modBase.getRoutePath(), routeEnd);
      else routeEnd = urlJoin(ownerModule.meta('route'), routeEnd);
    }
  } else if (routeEnd.indexOf('/') === 0) {
    routeBase = routeEnd; //absolute from app root 
  }
  if (!modBase) modBase = ownerModule;
  if (!routeBase) routeBase = urlJoin(modBase.getRoutePath(), routeEnd);
  //console.log(params)
  //console.log(routeBase);
  //console.log(modBase.namespace);
  return {route:routeBase, module:modBase};
}

ExModule.prototype.setData = function(name, value) {
  this._data[name] = value;
};

ExModule.prototype.getData = function(name, searchParent) {
  if (name in this._data) return this._data[name];
  if (searchParent) return this.parent.getData(name, searchParent);
};

/** 
 * Get or set meta data information of this module. This method sets the meta value only if it has not exist.
 */
ExModule.prototype.meta = function(name, value) {
  if (typeof value === 'undefined') return this._meta[name];
  else if (typeof this._meta[name] === 'undefined') this._meta[name] = value;
};

ExModule.prototype.init = function(initializerCallback) {
  if (typeof initializerCallback === 'function') this.main.init = initializerCallback;
};


/**
 * Mount the handler to the route: module_base_route/route
 * method : String (required) : The HTTP method to be handled.
 * route : String (required) : The relative route.
 * params:
 *   actionName : String : If specified, the route path will be accessible with the given name in the url view helper.
 *   label : String : If specified, the parent module will be notified that the handler has been added.
 *   Specify either one these, resolved in order of: route | interface | module
 *   interface | module : Request to adds the controller to the specified interface or module (namespaced), if exists. Default will mount the controller to the own module.
 *   route : String : An absolute base route path that will be prepended to the route. Ie: params.route/route
 */
/** params : (Optional)*/
ExModule.prototype.mount = function mount(method, route, params, callbacks) {
  if (!callbacks) {
    callbacks = params;
    params = {};
  }
  if (typeof params === 'string') {
    var name = params;
    params = {actionName:name};
  }
  try {
    var mod = this;
    var base = resolveBase(params, mod);
    //console.log('base.route:`%s` , route:`%s`', base.route, route);
    route = (base.route + route).replace(/\/+/g, '/');
    //console.log(params.label);
    if (params.label) base.module.registerResource(mod, params.label, route);
    //if (params.actionName) base.module._namedRoutes[params.actionName] = route;
    moduleManager.mount(method, route, new Entity(mod, base.module, '', params.actionName), callbacks);
    return route;
  } catch (e) {
    logger.error('mounting: {%s} %s %s', mod.namespace, method, route);
    logger.error(e);
  }
};

/**
 * Mount the controller to the route: module_base_route/controller_name
 * controller : Object (required) : The controller object or path to the js file, relative to the module dir.
 * params:
 *   name : String (auto) : Name of the controller, will be used in the routing path.
       Use string '/' to mount the controller as the default module handler.
 *   Specify either one these, resolved in order of: route | interface | module
 *   interface | module : Request to adds the controller to the specified interface or module (namespaced), if exists. Default will mount the controller to the parent module.
 *   route : String : An absolute base route path to mount the controller to, instead of the module base route. Ie: baseRoute/name
 *   handler : String : A handler in the specified interface/module
 *   layout : String : Absolute or relative path to layout template file.
 */
ExModule.prototype.mountController = function mountController(controller, params) {
  var mod = this;
  if (controller == null) {
    logger.error('Initialize module [%s]: mountController() : controller is not specified', mod.namespace);
    return;
  }
  if (params) {
    params.name = params.name || controller._params.name;
    params.interface = params.interface || controller._params.interface;
    params.module = params.module || controller._params.module;
    params.route = params.route || controller._params.route;
    controller.name = params.name;
  } else {
    params = controller._params;
  }
  //params.name = params.name || controller.controllerName || '';
  // Resolve route base path
  var base = resolveBase(params, mod);
  
  // Notify the parent module
  var name = params.name || mod.name;
  params.label = params.label || (name[0].toUpperCase() + name.slice(1));
  base.module.registerResource(mod, params.label, base.route);
  
  // Add actions to express route
  var callbacks;
  function processCallbacks(a) {
    if (Array.isArray(a)) {
      //a.forEach(function(b){callbacks.push(b.bind(controller));});
      a.forEach(function(b){callbacks.push(b);});
    } else if (typeof a === 'function') {
      //callbacks.push(a.bind(controller));
      callbacks.push(a);
    }
  }
  // if _actions array is undefined, the default is to use all the exported functions
  if (!Array.isArray(controller._actions)) {
    controller._actions = [];
    for (var key in controller) {
      if (key[0] !== '_' && typeof controller[key] === 'function') controller._actions.push(key);
    }
  }
  controller._actions.forEach(function(actionName) {
    var action = controller[actionName];
    if (typeof action !== 'function') return;
    callbacks = [];
    [controller[actionName+'_pre'], action.bind(controller), controller[actionName+'_post']].forEach(processCallbacks);
    if (callbacks.length > 0) {
      var method = controller[actionName+'_method'] || 'get';
      var route;
      if (controller[actionName+'_absroute']) {
        route = controller[actionName+'_absroute'];
      } else {
        var actionRoute = controller[actionName+'_route'];
        if (typeof actionRoute === 'string') route = base.route + actionRoute;
        else if (typeof cDef.routes[actionName] === 'string') route = base.route + cDef.routes[actionName];
        else route = urlJoin(base.route, actionName);
      }
      //base.module._namedRoutes[params.name + '.' + actionName] = route;
      //moduleManager.app[method](route, callbacks);
      moduleManager.mount(method, route, new Entity(mod, base.module, controller, actionName), callbacks);
    }
  });
  
};

ExModule.prototype.mountControllers = function(autoMount) {
  if (typeof autoMount === 'boolean') {
    this._autoMountControllers = autoMount;
  } else if (this._autoMountControllers) {
    this._autoMountControllers = false;
    for (var key in this.controllers) this.mountController(this.controllers[key]);
  }
};

/**
 * Add a controller to the module
 * controller : String | Object (required) : The controller object or path to the js file, relative to the module dir.
 * params:
 *   name : String (auto) : Name of the controller, will be used in the routing path. If not specified, the name of the js file will be used. 
       Use string '/' to mount the controller as the default module handler.
 *   Specify either one these, resolved in order of: route | interface | module
 *   interface | module : Request to adds the controller to the specified interface or module (namespaced), if exists. Default will mount the controller to the parent module.
 *   route : String : An absolute base route path to mount the controller to, instead of the module base route. Ie: baseRoute/name
 *   handler : String : A handler in the specified interface/module
 *   layout : String : Absolute or relative path to layout template file.
 */
ExModule.prototype.addController = function addController(controller, params) {
  if (typeof params !== 'object') params = {};
  var mod = this;
  var name = params.name;
  var routePath;
  var fullpath;
  logger.debug('{%s} add controller: `%s`', mod.namespace, controller);
  if (typeof controller === 'string') {
    // Resolve path and load controller object
    if (!name && path.basename(controller, '.js') === 'index') name = '';
    fullpath = path.resolve(mod.path, controller);
    controller = require(fullpath);
  } else if (!(controller instanceof Object)) {
    throw new Error('Error in initializing module [%s]: controller must be an object or a string.', mod.namespace);
  }
  if (typeof controller === 'function' && controller.name === 'init') controller = controller(mod, moduleManager);
  // Automatic naming based on object property or filename
  //console.log('controllername: %s', controller.controllerName);
  //console.log('params.name: %s', params.name);
  if (name == null) {
    if (typeof controller.name === 'string') name = controller.name;
    else if (fullpath) name = path.basename(fullpath, '.js');
    else throw new Error('Error in initializing module [%s]: Please specify a name for the controller.', mod.namespace);
  }
  //console.log('fullpath: %s', fullpath);
  //console.log('params.name: %s', params.name);
  if (name === '/') {
    //controller.controllerName = path.basename(mod.route);
    name = '';
  }
  controller._params = merge({}, params);
  controller._params.name = controller.name = name;
  // Add the controller
  mod.controllers[name] = controller;
  if (typeof controller._init === 'function') controller._init(mod, moduleManager);
  logger.debug('{%s} load and init controller `%s`', mod.namespace, name);
};

/** Load all js files from a directory. Non recursive */
ExModule.prototype.addControllers = function addControllers(pathToDir, params) {
  var mod = this;
  var basePath = path.resolve(mod.path, pathToDir);
  eachFileInDir(basePath, function(name, fullpath) {
    try {
      mod.addController(fullpath, params);
    } catch (err) {
      logger.error('{%s} Error loading controller: %s', mod.namespace, fullpath);
      logger.error(err);
    }
  });
  //    throw new Error('Error in initializing module [%s]: Error loading directory: %s', this._xmod.namespace, fullPath);
};

ExModule.prototype.addDefaultController = function addDefaultController(pathOrController) {
  this.addController(pathOrController, {name:'/'});
};

/**
 * Load the model to be made available to other modules
 * model : String | Object (required) : The model object or path to the js file, relative to the module dir.
 * params:
 *   name : String : Name of the model. If omitted, the model.modelName property will be used.
 */
ExModule.prototype.addModel = function addModel(model, params) {
  if (typeof params !== 'object') params = {};
  var mod = this;
  var filepath;
  if (!mod.models) mod.models = {};
  if (typeof model === 'string') {
    filepath = model;
    // Resolve path and load model object
    model = path.resolve(mod.path, model);
    model = require(model);
  } else if (!(model instanceof Object)) {
    throw new Error('Error in initializing module [%s]: model must be an object or a string.', mod.namespace);
  }
  if (typeof model === 'function' && model.name === 'init') model = model(mod, moduleManager);

  // Automatic naming based on modelName and filename
  if (!params.name) {
    if (model.modelName) params.name = model.modelName;
    else params.name = path.basename(filepath, '.js');
  }
  mod.models[params.name] = model;
};

/** Load all models from a directory. Non recursive */
ExModule.prototype.addModels = function addModels(pathToDir) {
  var basePath = path.resolve(this.path, pathToDir);
  var mod = this;
  try {
    eachFileInDir(basePath, function(name, fullpath) { mod.addModel(fullpath); } );
  } catch (err) {
    logger.error('{%s} Error loading models: %s', this.namespace, pathToDir);
    logger.error(err);
  }
  
};

ExModule.prototype.addView = function addView(pathToTemplate, name) {
  var mod = this;
  var fullpath = path.resolve(mod.path, pathToTemplate);
  //var ext = path.extname(pathToTemplate);
  //if (!template) { // load template from file
  //  template = fs.readFileSync(fullpath,'utf8');
  //}
  if (!name) name = path.basename(pathToTemplate);
  //if (!mod.views) mod.views = {};
  //if (!(name in mod.views)) mod.views[name] = {};
  //extension without dot
  //ext = ext.slice(1);
  mod.views[name] = fullpath;
};

ExModule.prototype.addViews = function addViews(pathToDir) {
  //console.log('addView: %s', this.name);
  var mod = this;
  var basePath = path.resolve(mod.path, pathToDir);
  try {
    eachFileInDir(basePath, function(name, fp) {
      mod.addView(fp, path.relative(basePath, fp));
    }, true);
  } catch (err) {
    logger.error('{%s} Error loading views: %s', this.namespace, pathToDir);
    logger.error(err);
  }
};

ExModule.prototype.addStatic = function(pathToDir, params) {
  params = params || {};
  var staticPath = path.resolve(this.path, pathToDir);
  if (!params.name) params.name = path.basename(pathToDir);
  var base = resolveBase(params, this);
  var route = base.route;
  this._namedRoutes[params.name] = route;
  route = route + '/*';
  moduleManager.app.get(route, function serveStatic(req, res) {
    //console.log('static');
    var filepath = path.join(staticPath, req.params[0]);
    //console.log(filepath);
    res.sendfile(filepath, function(err){
      res.send(404, 'Cannot GET ' + req.url);
    });
  });
  logger.debug('mounted static: %s %s', route, staticPath);
  //moduleManager.app.use(name, express.static(staticPath));
};

ExModule.prototype.injectHandlers = function(type, entityIdentifier, callbacks) {
  if (!(type in {'pre':0, 'post':0})) return;
  var handlers = this._externalHandlers;
  if (!(type in handlers)) handlers[type] = {};
  if (!(entityIdentifier in handlers[type])) handlers[type][entityIdentifier] = [];
  var list = handlers[type][entityIdentifier];
  if (!Array.isArray(callbacks)) callbacks = [callbacks];
  callbacks.forEach(function(cb) { list.push(cb); });
};

ExModule.prototype.beforeExternalMount = function(entityIdentifier, method, route, callbacks) {
  if (method && route && callbacks) { //add the route
  } else { //get the routes
  }
};

ExModule.prototype.setResourceHandler = function(callback) {
  this.main.onRegisterResource = callback;
};

ExModule.prototype.setLocalsHandler = function(callback) {
  this.main.prepareViewLocals = callback;
};

ExModule.prototype.setPartialView = function(name, value) {
  moduleManager.helper.view.setPartial(name, value);
};

ExModule.prototype.routePathTo = function routePathTo(relativeRoute) {
//  var r = this.fullRoute;
//  if (r[r.length - 1] === '/' && relativeRoute[0] === '/') return r + relativeRoute.slice(1);
//  else return r + relativeRoute;
  return (this.fullRoute + relativeRoute).replace(/^\/+/, '/');
};

ExModule.prototype.beforeMount = function(fn) {
  this._event.on('beforeMount', fn);
};
ExModule.prototype.afterMount = function(fn) {
  this._event.on('afterMount', fn);
};